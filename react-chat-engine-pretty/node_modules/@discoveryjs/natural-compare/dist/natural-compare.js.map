{
  "version": 3,
  "sources": ["../cjs/index.cjs"],
  "sourcesContent": ["'use strict';\n\nconst TYPE_EOF = 0;\nconst TYPE_WS = 1;\nconst TYPE_DELIM = 2;\nconst TYPE_NUM = 3;\nconst TYPE_WORD = 4;\n\nconst safeCharCodeAt = (source, offset) => offset < source.length ? source.charCodeAt(offset) : 0;\nconst isSign = (code) => code === 0x002B || code === 0x002D;\nconst isDigit = (code) => code >= 0x0030 && code <= 0x0039;\nconst isWS = (code) => (\n    code === 0x0009 ||  // \\t\n    code === 0x000A ||  // \\n\n    code === 0x000C ||  // \\f\n    code === 0x000D ||  // \\r\n    code === 0x0020     // whitespace\n);\nconst isDelim = (code) => (\n    (code > 0x0020 && code < 0x0100) &&  // ascii char\n    (code < 0x0041 || code > 0x005A) &&  // not A..Z\n    (code < 0x0061 || code > 0x007A) &&  // not a..z\n    (code < 0x0030 || code > 0x0039) &&  // not 0..9\n    code !== 0x002B &&                   // not +\n    code !== 0x002D                      // not -\n) || code === 0x2116;  /* \u2116 */\n\n//  Check if three code points would start a number\nfunction isNumberStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002B PLUS SIGN (+)\n    // U+002D HYPHEN-MINUS (-)\n    if (isSign(first)) {\n        // If the second code point is a digit, return true.\n        if (isDigit(second)) {\n            return 2;\n        }\n\n        // Otherwise, if the second code point is a U+002E FULL STOP (.)\n        // and the third code point is a digit, return true.\n        // Otherwise, return false.\n        return second === 0x002E && isDigit(third) ? 3 : 0;\n    }\n\n    // U+002E FULL STOP (.)\n    // if (first === 0x002E) {\n    //     // If the second code point is a digit, return true. Otherwise, return false.\n    //     return isDigit(second) ? 2 : 0;\n    // }\n\n    // digit\n    if (isDigit(first)) {\n        // Return true.\n        return 1;\n    }\n\n    // anything else\n    // Return false.\n    return 0;\n}\n\nfunction findDecimalNumberEnd(source, offset) {\n    while (isDigit(safeCharCodeAt(source, offset))) {\n        offset++;\n    }\n\n    return offset;\n}\n\nfunction consumeNumber(source, offset, preventFloat) {\n    let code = safeCharCodeAt(source, offset);\n\n    // If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n    // consume it and append it to repr.\n    if (isSign(code)) {\n        code = safeCharCodeAt(source, offset += 1);\n    }\n\n    // While the next input code point is a digit, consume it and append it to repr.\n    if (isDigit(code)) {\n        offset = findDecimalNumberEnd(source, offset + 1);\n        code = safeCharCodeAt(source, offset);\n    }\n\n    // If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n    if (code === 0x002E && isDigit(safeCharCodeAt(source, offset + 1))) {\n        if (preventFloat) {\n            return offset;\n        }\n\n        // Consume them\n        let expectedEnd = offset + 2;\n\n        // While the next input code point is a digit, consume it and append it to repr.\n        expectedEnd = findDecimalNumberEnd(source, expectedEnd);\n\n        // If next char is U+002E FULL STOP (.), then don't consume\n        if (safeCharCodeAt(source, expectedEnd) === 0x002E) {\n            return offset;\n        }\n\n        offset = expectedEnd;\n    }\n\n    // If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n    code = safeCharCodeAt(source, offset);\n    if (code === 0x0045 /* e */ || code === 0x0065 /* E */) {\n        let sign = 0;\n        code = safeCharCodeAt(source, offset + 1);\n\n        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n        if (isSign(code)) {\n            sign = 1;\n            code = safeCharCodeAt(source, offset + 2);\n        }\n\n        // ... followed by a digit\n        if (isDigit(code)) {\n            // While the next input code point is a digit, consume it and append it to repr.\n            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n        }\n    }\n\n    return offset;\n}\n\nfunction getPart(source, offset, preventFloat, preventSign) {\n    if (offset >= source.length) {\n        return TYPE_EOF;\n    }\n\n    let a = safeCharCodeAt(source, offset);\n\n    // Whitespace\n    if (isWS(a)) {\n        let end = offset + 1;\n\n        while (isWS(safeCharCodeAt(source, end))) {\n            end++;\n        }\n\n        return TYPE_WS | (end - offset << 3);\n    }\n\n    // Delim sequence\n    // console.log(source[offset], isDelim(a), a.toString(16), preventSign)\n    if (isDelim(a) || (preventSign && isSign(a))) {\n        let end = offset + 1;\n        let b = a;\n\n        do {\n            a = b;\n            b = safeCharCodeAt(source, end++);\n        } while (isDelim(b) || b === a);\n\n        return TYPE_DELIM | (end - offset - 1 << 3);\n    }\n\n    // Number\n    let b = safeCharCodeAt(source, offset + 1);\n    let c = safeCharCodeAt(source, offset + 2);\n    if (isNumberStart(a, b, c)) {\n        return TYPE_NUM | (consumeNumber(source, offset, preventFloat) - offset << 3);\n    }\n\n    // Word\n    let end = offset;\n    do {\n        a = b;\n        b = c;\n        c = safeCharCodeAt(source, 3 + end++);\n    } while (end < source.length && !isWS(a) && !isDelim(a) && !isDigit(a));\n\n    return TYPE_WORD | (end - offset << 3);\n}\n\nfunction compare(a, b, analytical) {\n    let offsetA = 0;\n    let offsetB = 0;\n    let preventFloat = false;\n    let preventSign = false;\n    let postCmpResult = 0;\n    let postCmpResultType = 0;\n    let firstPart = true;\n\n    do {\n        const partA = getPart(a, offsetA, preventFloat, preventSign);\n        const partB = getPart(b, offsetB, preventFloat, preventSign);\n        const typeA = partA & 7;\n        const lenA = partA >> 3;\n        const typeB = partB & 7;\n        const lenB = partB >> 3;\n\n        if (typeA !== typeB && firstPart) {\n            if ((typeA === TYPE_WS || typeA === TYPE_DELIM) && (typeB === TYPE_NUM || typeB === TYPE_WORD)) {\n                postCmpResult = 1;\n                postCmpResultType = typeA;\n                offsetA += lenA;\n                continue;\n            }\n\n            if ((typeB === TYPE_WS || typeB === TYPE_DELIM) && (typeA === TYPE_NUM || typeA === TYPE_WORD)) {\n                postCmpResult = -1;\n                postCmpResultType = typeB;\n                offsetB += lenB;\n                continue;\n            }\n        }\n\n        firstPart = false;\n\n        if (typeA !== typeB) {\n            return typeA < typeB ? -1 : 1;\n        }\n\n        preventFloat = false;\n        preventSign = false;\n\n        // both parts are the same type, no matter which type to test\n        if (typeA === TYPE_EOF) {\n            return postCmpResult;\n        }\n\n        // find difference in substr\n        const minLength = lenA < lenB ? lenA : lenB;\n        let substrDiff = lenA - lenB;\n        let substrDiffIdx = 0;\n        for (; substrDiffIdx < minLength; substrDiffIdx++) {\n            const cA = a[offsetA + substrDiffIdx];\n            const cB = b[offsetB + substrDiffIdx];\n\n            if (cA !== cB) {\n                substrDiff = cA < cB ? -1 : 1;\n                break;\n            }\n        }\n\n        // both parts are the same type, no matter which type to test\n        if (typeA === TYPE_WS || typeA === TYPE_DELIM) {\n            if (substrDiff !== 0 && (postCmpResult === 0 || typeA > postCmpResultType)) {\n                postCmpResultType = typeA;\n                postCmpResult = substrDiff;\n            }\n\n            preventFloat = a[offsetA + lenA - 1] === '.';\n        } else if (typeA === TYPE_NUM) {\n            preventSign = true;\n\n            if (substrDiff !== 0) {\n                const numDiff = a.substr(offsetA, lenA) - b.substr(offsetB, lenB);\n\n                if (numDiff !== 0) {\n                    return analytical ? -numDiff : numDiff;\n                }\n\n                if (postCmpResult === 0 || typeA > postCmpResultType) {\n                    const afc = safeCharCodeAt(a, offsetA);\n                    const bfc = safeCharCodeAt(b, offsetB);\n                    const order = afc === 0x002D ? -1 : 1;\n\n                    // a/b  -  o  +\n                    //   -  0 -1 -1\n                    //   o  1  0 -1\n                    //   +  1  1  0\n\n                    postCmpResultType = typeA;\n                    postCmpResult = afc !== bfc && (afc === 0x002D /* - */ || bfc === 0x002B /* + */)\n                        ? -1\n                        : afc !== bfc && (afc === 0x002B /* + */ || bfc === 0x002D /* - */)\n                            ? 1\n                            : (lenA !== lenB ? lenA < lenB : substrDiff < 0) ? -order : order;\n\n                    if (analytical) {\n                        postCmpResult = -postCmpResult;\n                    }\n                }\n            }\n        } else { // typeA === TYPE_WORD\n            if (substrDiff !== 0) {\n                if (substrDiffIdx < minLength) {\n                    // case insensitive checking\n                    let cnA = a[offsetA + substrDiffIdx].toLowerCase();\n                    let cnB = b[offsetB + substrDiffIdx].toLowerCase();\n\n                    if (cnA !== cnB) {\n                        return cnA < cnB ? -1 : 1;\n                    }\n                }\n\n                return substrDiff;\n            }\n\n            preventFloat = a[offsetA + lenA - 1] === '.';\n        }\n\n        offsetA += lenA;\n        offsetB += lenB;\n    } while (true);\n}\n\nfunction naturalCompare(a, b) {\n    const typeA = typeof a;\n    const typeB = typeof b;\n    let ret = 0;\n\n    if ((typeA === 'number' || typeA === 'string') && (typeB === 'number' || typeB === 'string')) {\n        ret = Math.sign(compare(String(a), String(b), false));\n    }\n\n    return ret;\n}\n\nfunction naturalAnalyticalCompare(a, b) {\n    const typeA = typeof a;\n    const typeB = typeof b;\n    let ret = 0;\n\n    if ((typeA === 'number' || typeA === 'string') && (typeB === 'number' || typeB === 'string')) {\n        ret = Math.sign(compare(String(a), String(b), true));\n    }\n\n    return ret;\n}\n\nexports.naturalAnalyticalCompare = naturalAnalyticalCompare;\nexports.naturalCompare = naturalCompare;\n"],
  "mappings": "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",
  "names": []
}
