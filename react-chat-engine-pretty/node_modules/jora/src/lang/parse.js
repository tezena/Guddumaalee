/* parser generated by jison 0.4.18-remastered.5 */
let o=function(keys, v, o = {}) {
            keys.forEach(key => o[key] = v);
            return o;
        },$V0=[2,5],$V1=[1,13],$V2=[1,41],$V3=[1,18],$V4=[1,7],$V5=[1,8],$V6=[1,10],$V7=[1,11],$V8=[1,12],$V9=[1,19],$V10=[1,20],$V11=[1,21],$V12=[1,22],$V13=[1,23],$V14=[1,24],$V15=[1,25],$V16=[1,29],$V17=[1,32],$V18=[1,33],$V19=[1,34],$V20=[1,35],$V21=[1,36],$V22=[1,37],$V23=[1,42],$V24=[1,43],$V25=[1,40],$V26=[5,18,56,59],$V27=[1,47],$V28=[1,55],$V29=[1,54],$V30=[1,48],$V31=[1,49],$V32=[1,50],$V33=[1,51],$V34=[1,52],$V35=[1,53],$V36=[1,56],$V37=[1,57],$V38=[1,58],$V39=[1,59],$V40=[1,60],$V41=[1,61],$V42=[1,62],$V43=[1,63],$V44=[1,64],$V45=[1,65],$V46=[1,66],$V47=[5,9,14,15,17,18,19,22,23,24,44,45,46,47,48,49,50,54,56,58,59,60,61,62,63,64,72,73,76,77,80],$V48=[5,10,11,18,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,56,59,66,74,75,77],$V49=[1,67],$V50=[1,68],$V51=[1,69],$V52=[1,70],$V53=[1,71],$V54=[1,72],$V55=[1,73],$V56=[1,76],$V57=[5,18,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,54,56,59,60,61,62,63,64,66,74,75,77,84],$V58=[2,46],$V59=[1,82],$V60=[1,83],$V61=[2,48],$V62=[1,84],$V63=[1,86],$V64=[5,10,11,18,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,54,56,59,60,61,62,63,64,66,74,75,77,84],$V65=[5,10,11,18,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,54,56,58,59,60,61,62,63,64,66,74,75,77,84],$V66=[1,93],$V67=[1,94],$V68=[1,95],$V69=[1,111],$V70=[1,110],$V71=[1,116],$V72=[1,119],$V73=[1,120],$V74=[1,121],$V75=[1,122],$V76=[1,123],$V77=[9,14,15,17,19,22,23,24,44,45,46,47,48,49,50,54,58,60,61,62,63,64,72,73,74,75,76],$V78=[5,10,11,18,21,56,59,66,74,75,77],$V79=[5,10,11,18,21,29,30,41,56,59,66,74,75,77],$V80=[5,10,11,18,21,23,24,25,26,27,28,29,30,34,35,36,37,38,39,40,41,56,59,66,74,75,77],$V81=[56,66],$V82=[2,115],$V83=[11,56],$V84=[66,77],$V85=[2,102],$V86=[2,103],$V87=[5,10,11,18,21,25,26,27,28,29,30,41,56,59,66,74,75,77],$V88=[5,10,11,18,21,25,26,27,28,29,30,34,35,40,41,56,59,66,74,75,77],$V89=[5,10,11,18,21,25,26,27,28,29,30,34,35,36,37,38,39,40,41,56,59,66,74,75,77],$V90=[1,199],$V91=[1,201],$V92=[59,66],$V93=[1,211],$V94=[2,109];
const lexer = (function(){
/* Lexer generated by jison 0.4.18-remastered.5 */
const lexer = {
yy:{},
options: {"ranges":true},
rules: [/^(?:\/\/.*?(?:\n|\r\n?|\u2028|\u2029|$)|\/\*(?:.|\s)*?(?:\*\/|$))/,/^\s+/,/^\//,/^<(?!=)/,/^/,(input, state) => {
    if (input[0] !== (state === 'template' ? '}' : '`')) {
        return null;
    }

    for (let i = 1; i < input.length; i++) {
        if (input[i] === '`') {
            return i + 1;
        }

        if (input[i] === '$' && input[i + 1] === '{') {
            return i + 2;
        }

        if (input[i] === '\\') {
            i++;
        }
    }

    return null;
},(input, state) => {
    if (input[0] !== (state === 'template' ? '}' : '`')) {
        return null;
    }

    for (let i = 1; i < input.length; i++) {
        if (input[i] === '`') {
            return i + 1;
        }

        if (input[i] === '$' && input[i + 1] === '{') {
            return i + 2;
        }

        if (input[i] === '\\') {
            i++;
        }
    }

    return null;
},/^/,/^\(/,/^\)/,/^\[/,/^\]/,/^\{/,/^\}/,/^(?:(true|false|null|undefined|Infinity|NaN)\b)/,/^and\b/,/^or\b/,/^has\s+no\b/,/^has\b/,/^in\b/,/^not\s+in\b/,/^not?\b/,/^(?:(asc|desc)(NA?|AN?)?\b)/,/^(?:(\d+\.|\.)?\d+([eE][-+]?\d+)?\b)/,/^0[xX][0-9a-fA-F]+/,/^(?:"(?:\\[\\"]|[^"])*")/,/^(?:'(?:\\[\\']|[^'])*')/,/^(?:\/(?:\\.|[^/])+\/[gimsu]*)/,/^(?:(?:[a-zA-Z_]|\\u[0-9a-fA-F]{4})(?:[a-zA-Z_$0-9]|\\u[0-9a-fA-F]{4})*)/,/^(?:\$(?:[a-zA-Z_]|\\u[0-9a-fA-F]{4})(?:[a-zA-Z_$0-9]|\\u[0-9a-fA-F]{4})*)/,/^@/,/^#/,/^\$\$/,/^\$/,/^=>/,/^<(?!=)/,/^=/,/^!=/,/^~=/,/^>=/,/^<=/,/^</,/^>/,/^\.\.\(/,/^\.\(/,/^\.\[/,/^\.\.\./,/^\.\./,/^\./,/^\?/,/^,/,/^:/,/^;/,/^\-/,/^\+/,/^\*/,/^\//,/^\%/,/^(?:\|)/,/^./,/^$/],
conditions: {"preventPrimitive":{"rules":[0,1,2,3,4,5,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60],"inclusive":true},"template":{"rules":[6,7],"inclusive":false},"INITIAL":{"rules":[0,1,5,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60],"inclusive":true}},
performAction(yy,yy_,__lexelActionId,YY_START) {

const YYSTATE=YY_START;
switch (__lexelActionId) {
case 0:{yy.commentRanges.push(yy_.yylloc.range)
break;}
case 1:{
break;}
case 2:{this.popState(); return 32;
break;}
case 3:{this.popState(); return 36;
break;}
case 4:{this.done = false;
            this.popState();
break;}
case 5:{const token = yy_.yytext.endsWith('`') ? 'TEMPLATE' : 'TPL_START';
            yy_.yytext = this.toStringLiteral(yy_.yytext, true, 1 + Number(token !== 'TEMPLATE'));
            if (token === 'TEMPLATE') {
                yy.pps();
            }
            return token;
break;}
case 6:{const token = yy_.yytext.endsWith('`') ? 'TPL_END' : 'TPL_CONTINUE';
            yy_.yytext = this.toStringLiteral(yy_.yytext, true, 1 + Number(token !== 'TPL_END'));
            this.popState();
            if (token === 'TPL_END') {
                yy.pps();
            }
            return token;
break;}
case 7:{this.parseError('Unexpected end of input');
break;}
case 8:{return 58;
break;}
case 9:{yy.pps(); return 59;
break;}
case 10:{return 54;
break;}
case 11:{yy.pps(); return 56;
break;}
case 12:{return 76;
break;}
case 13:{if (this.bracketStack[this.bracketStack.length - 1] !== 'TPL_END') {
                yy.pps();
                return 77;
            }

            this.unput('}');
            this.begin('template');
break;}
case 14:{yy_.yytext = this.toLiteral(yy_.yytext); // eslint-disable-line no-unused-vars
            return 50;
break;}
case 15:{return 29;
break;}
case 16:{return 30;
break;}
case 17:{return 28;
break;}
case 18:{return 26;
break;}
case 19:{return 25;
break;}
case 20:{return 27;
break;}
case 21:{return 22;
break;}
case 22:{return 84;
break;}
case 23:{yy.pps(); yy_.yytext = Number(yy_.yytext); return 48;
break;}
case 24:{yy.pps(); yy_.yytext = parseInt(yy_.yytext, 16); return 48;
break;}
case 25:{yy.pps(); yy_.yytext = this.toStringLiteral(yy_.yytext); return 47;
break;}
case 26:{yy.pps(); yy_.yytext = this.toStringLiteral(yy_.yytext); return 47;
break;}
case 27:{yy.pps(); yy_.yytext = this.toRegExp(yy_.yytext); return 49;
break;}
case 28:{yy.pps(); yy_.yytext = this.ident(yy_.yytext); return 14;
break;}
case 29:{yy.pps(); yy_.yytext = this.ident(yy_.yytext.slice(1)); return 15;
break;}
case 30:{yy.pps(); return 44;
break;}
case 31:{yy.pps(); return 45;
break;}
case 32:{yy.pps(); return 46;
break;}
case 33:{yy.pps(); return 9;
break;}
case 34:{return 19;
break;}
case 35:{this.fnOpened++;
            return 17;
break;}
case 36:{return 34;
break;}
case 37:{return 35;
break;}
case 38:{return 40;
break;}
case 39:{return 39;
break;}
case 40:{return 37;
break;}
case 41:{return 36;
break;}
case 42:{if (this.fnOpened) {
                this.fnOpened--;
                return 18;
            }
            return 38;
break;}
case 43:{return 64;
break;}
case 44:{return 61;
break;}
case 45:{return 62;
break;}
case 46:{return 80;
break;}
case 47:{yy.pps(); return 63;
break;}
case 48:{yy.pps(); return 60;
break;}
case 49:{return 41;
break;}
case 50:{return 66;
break;}
case 51:{return 11;
break;}
case 52:{return 10;
break;}
case 53:{return 23;
break;}
case 54:{return 24;
break;}
case 55:{return 31;
break;}
case 56:{return 32;
break;}
case 57:{return 33;
break;}
case 58:{return 21;
break;}
case 59:{this.parseError(`Bad input on line ${yy_.yylloc.first_line} column ${yy_.yylloc.first_column}\n` + this.showPosition(), {
                text: yy_.yytext,
                token: 'BAD_TOKEN'
            });
break;}
case 60:{return 5;
break;}
}
},
    setInput(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = false;
        this._backtrack = false;
        this.done = false;
        this.currentCondition = 'INITIAL';
        this.conditionStack = ['INITIAL'];
        this.offset = 0;
        this.yytext = this.match = '';
        this.yyleng = 0;
        this.yylineno = 0;
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };

        if (true) {
            this.yylloc.range = [0, 0];
        }

        return this;
    },
    parseError(str, details) {
        if (!this.yy.parser) {
            throw new Error(str);
        }

        this.yy.parser.parseError(str, details);
    },
    input() {
        const ch = this._input[this.offset];
        const newline = /\n|\r\n?|\u2028|\u2029/g.test(ch);

        this.offset++;
        this.yyleng++;
        this.yytext = this.match = this.yytext + ch;

        if (newline) {
            this.yylineno++;
            this.yylloc.last_line++;
            this.yylloc.last_column = 0;
        } else {
            this.yylloc.last_column++;
        }

        if (true) {
            this.yylloc.range[1]++;
        }

        return ch;
    },
    lineColumnForOffset(offset = this.offset, str = this._input, startLine = 1, startColumn = 0) {
        const rx = /\n|\r\n?|\u2028|\u2029/g;
        let line = startLine;
        let column = startColumn;
        let prevLastIndex = 0;
        let match;

        while ((match = rx.exec(str)) !== null) {
            if (match.index < offset) {
                line++;
                column = 0;
                prevLastIndex = match.index + match[0].length;
            } else {
                column += offset - prevLastIndex;
                prevLastIndex = -1;
                break;
            }
        }

        if (prevLastIndex !== -1) {
            column += offset - prevLastIndex;
        }

        return {
            line,
            column
        };
    },
    setMatch(start, end) {
        const newMatch = this._input.slice(start, end);
        const firstLoc = start !== this.offset ? this.lineColumnForOffset(start) : {
            line: this.yylloc.last_line,
            column: this.yylloc.last_column
        };
        const lastLoc = start !== end
            ? this.lineColumnForOffset(end - start, newMatch, firstLoc.line, firstLoc.column)
            : firstLoc;

        this.yytext = this.match = newMatch;
        this.yyleng = end - start;
        this.offset = end;

        this.yylineno = lastLoc.line - 1;
        this.yylloc = {
            first_line: firstLoc.line,
            first_column: firstLoc.column,
            last_line: lastLoc.line,
            last_column: lastLoc.column
        };

        if (true) {
            this.yylloc.range = [start, end];
        }
    },
    less(n) {
        const start = this.offset - this.match.length;

        this.setMatch(start, start + n);
    },
    unput(chunk) {
        const newMatchLength = this.match.length - chunk.length;

        if (!this.match.startsWith(chunk, newMatchLength)) {
            throw new Error('Lexer#unput() should receive a part of matched text only');
        }

        this.less(newMatchLength);
    },
    more() {
        this._more = true;
    },
    reject() {
        if (false) {
            this._backtrack = true;
            return;
        }

        // FIXME: remove method when options.backtrack_lexer is false
        throw new Error('reject() is allowed only when options.backtrack_lexer = true');
    },
    showPosition(offset = this.offset - this.match.length) {
        const input = this._input;
        const start = Math.max(offset - 20, 0);
        const end = Math.min(offset + 20, input.length);
        const pre = (start === 0 ? '' : '...') + input.slice(start, offset).replace(/\n|\r\n?|\u2028|\u2029/g, '\\n');
        const post = input.slice(offset, end).replace(/\n|\r\n?|\u2028|\u2029/g, '\\n') + (end === input.length ? '' : '...');

        return (
            pre +
            post +
            `\n${'-'.repeat(pre.length)}^`
        );
    },
    test_match(match, rule) {
        let backup;

        if (false) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylloc.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };

            if (true) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        this._more = false;
        this._backtrack = false;
        this.setMatch(this.offset, this.offset + match[0].length);
        this.matches = match;

        // perform action
        const token = this.performAction.call(
            this,
            this.yy,
            this,
            rule,
            this.conditionStack[this.conditionStack.length - 1]
        );

        if (!token && this._backtrack) {
            // recover context
            Object.assign(this, backup);

            return false; // rule action called reject() implying the next rule should be tested instead.
        }

        if (!this.eof()) {
            this.done = false;
        }

        if (typeof token === 'number' && this.yy.parser) {
            return this.yy.parser.terminals_[token];
        }

        return token || false;
    },
    eof() {
        return this.offset === this._input.length;
    },
    next() {
        if (this.done) {
            return 1; // EOF
        }

        if (this.eof()) {
            this.done = true;
        }

        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }

        let match;
        let matchRuleId;

        for (const ruleId of this.conditions[this.currentCondition].rules) {
            const rule = this.rules[ruleId];
            const ruleInput = this._input.slice(this.offset);
            let tempMatch;

            if (typeof rule === 'function') {
                const ret = rule(ruleInput, this.currentCondition);

                switch (typeof ret) {
                    case 'string': tempMatch = [ret]; break;
                    case 'number': tempMatch = [ruleInput.slice(0, ret)]; break;
                    default: tempMatch = ret;
                }
            } else {
                tempMatch = ruleInput.match(rule);
            }

            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                matchRuleId = ruleId;

                if (false) {
                    const token = this.test_match(tempMatch, matchRuleId);

                    if (token === false && this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    }

                    // when token is false this is a lexer rule which consumes
                    // input without producing a token (e.g. whitespace)
                    return token;
                }

                if (!false) {
                    break;
                }
            }
        }

        if (match) {
            // when token is false this is a lexer rule which consumes
            // input without producing a token (e.g. whitespace)
            return this.test_match(match, matchRuleId);
        }

        if (this.eof()) {
            return 1; // EOF
        }

        this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
            text: '',
            token: null,
            line: this.yylineno
        });
    },
    lex() {
        let token;

        while (!token) {
            token = this.next();
        }

        return token;
    },
    begin(condition) {
        this.currentCondition = condition;
        this.conditionStack.push(condition);
    },
    pushState(condition) {
        this.begin(condition);
    },
    popState() {
        this.conditionStack.pop();

        return this.currentCondition = (this.conditionStack.length
            ? this.conditionStack[this.conditionStack.length - 1]
            : 'INITIAL'
        );
    },
    topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);

        return n >= 0
            ? this.conditionStack[n]
            : 'INITIAL';
    },
    stateStackSize() {
        return this.conditionStack.length;
    }
};
return lexer;
})();
;
function Parser() {
  this.yy = {};
}
Parser.prototype = {Parser,
lexer,
symbols_: {"error":2,"root":3,"block":4,"EOF":5,"definitions":6,"e":7,"def":8,"$":9,";":10,":":11,"$ident":12,"ident":13,"IDENT":14,"$IDENT":15,"query":16,"FUNCTION_START":17,"FUNCTION_END":18,"FUNCTION":19,"sortingCompareList":20,"|":21,"NOT":22,"-":23,"+":24,"IN":25,"HAS":26,"NOTIN":27,"HASNO":28,"AND":29,"OR":30,"*":31,"/":32,"%":33,"=":34,"!=":35,"<":36,"<=":37,">":38,">=":39,"~=":40,"?":41,"queryRoot":42,"relativePath":43,"@":44,"#":45,"$$":46,"STRING":47,"NUMBER":48,"REGEXP":49,"LITERAL":50,"template":51,"object":52,"array":53,"[":54,"sliceNotation":55,"]":56,"method()":57,"(":58,")":59,".":60,".(":61,".[":62,"..":63,"..(":64,"arguments":65,",":66,"templateString":67,"templateStart":68,"templateTail":69,"templateEnd":70,"templateContinue":71,"TEMPLATE":72,"TPL_START":73,"TPL_CONTINUE":74,"TPL_END":75,"{":76,"}":77,"objectEntries":78,"objectEntry":79,"...":80,"arrayElements":81,"arrayElement":82,"sortingCompare":83,"ORDER":84,"sliceNotationComponent":85,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",9:"$",10:";",11:":",14:"IDENT",15:"$IDENT",17:"FUNCTION_START",18:"FUNCTION_END",19:"FUNCTION",21:"|",22:"NOT",23:"-",24:"+",25:"IN",26:"HAS",27:"NOTIN",28:"HASNO",29:"AND",30:"OR",31:"*",32:"/",33:"%",34:"=",35:"!=",36:"<",37:"<=",38:">",39:">=",40:"~=",41:"?",44:"@",45:"#",46:"$$",47:"STRING",48:"NUMBER",49:"REGEXP",50:"LITERAL",54:"[",56:"]",58:"(",59:")",60:".",61:".(",62:".[",63:"..",64:"..(",66:",",72:"TEMPLATE",73:"TPL_START",74:"TPL_CONTINUE",75:"TPL_END",76:"{",77:"}",80:"...",84:"ORDER"},
productions_: [0,[3,2],[4,2],[4,1],[4,1],[4,0],[6,1],[6,2],[8,2],[8,4],[8,2],[8,4],[13,1],[12,1],[7,1],[7,3],[7,2],[7,1],[7,3],[7,4],[7,2],[7,2],[7,2],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,5],[16,1],[16,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,3],[42,1],[42,1],[42,3],[42,4],[42,2],[42,2],[42,3],[42,3],[42,2],[42,2],[42,3],[43,3],[43,4],[43,4],[43,3],[43,3],[43,4],[43,4],[43,3],[43,3],[43,4],[57,3],[57,4],[57,3],[57,4],[65,1],[65,3],[51,1],[51,2],[69,1],[69,2],[69,2],[69,3],[67,1],[68,1],[71,1],[70,1],[52,2],[52,3],[52,4],[52,3],[52,4],[52,5],[78,1],[78,3],[79,1],[79,1],[79,1],[79,3],[79,3],[79,3],[79,3],[79,3],[79,5],[79,1],[79,2],[81,1],[81,3],[82,1],[82,1],[82,2],[53,2],[53,3],[53,4],[20,1],[20,3],[83,2],[55,1],[55,2],[55,2],[55,3],[85,1],[85,2]],
table: [{3:1,4:2,5:$V0,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{1:[3]},{5:[1,44]},o($V26,[2,3],{16:6,20:9,12:14,42:15,43:16,83:17,51:26,52:27,53:28,13:30,57:31,67:38,68:39,7:45,8:46,9:$V1,14:$V2,15:$V3,17:$V4,19:$V5,22:$V6,23:$V7,24:$V8,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,54:$V16,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,72:$V23,73:$V24,76:$V25}),o($V26,[2,4],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V47,[2,6]),o($V48,[2,14],{54:$V49,60:$V50,61:$V51,62:$V52,63:$V53,64:$V54,84:$V55}),{4:74,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,18:$V0,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:75,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o([5,10,11,18,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,56,59,74,75,77],[2,17],{66:[1,78]}),{7:79,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:80,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:81,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V57,$V58,{10:$V59,11:$V60}),o($V57,$V61,{10:$V62,11:[1,85],58:$V63}),o($V64,[2,42]),o($V64,[2,43]),o($V48,[2,121]),o($V65,[2,13]),o($V64,[2,44]),o($V64,[2,45]),o($V64,[2,47]),o($V64,[2,49]),o($V64,[2,50]),o($V64,[2,51]),o($V64,[2,52]),o($V64,[2,53]),o($V64,[2,54]),o($V64,[2,55]),{7:91,9:$V56,11:$V66,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,55:87,56:[1,88],57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,80:$V67,81:89,82:92,83:17,85:90},o($V64,[2,57],{58:$V68}),o($V64,[2,58]),{6:97,7:96,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{12:100,13:98,14:$V2,15:$V3,57:99},{4:101,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,59:$V0,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{4:102,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,56:$V0,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{12:100,13:103,14:$V2,15:$V3,57:104},{4:105,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,59:$V0,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V64,[2,84]),{7:108,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,69:106,70:107,71:109,72:$V23,73:$V24,74:$V69,75:$V70,76:$V25,83:17},{6:114,8:5,9:$V71,12:117,13:118,14:$V2,15:$V3,47:$V72,48:$V73,50:$V74,54:$V75,77:[1,112],78:113,79:115,80:$V76},o($V65,[2,12]),o($V64,[2,90]),o($V77,[2,91]),{1:[2,1]},o($V26,[2,2],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V47,[2,7]),{6:125,7:124,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:126,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:127,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:128,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:129,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:130,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:131,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:132,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:133,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:134,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:135,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:136,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:137,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:138,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:139,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:140,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:141,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:142,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:143,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:144,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:146,9:$V56,11:$V66,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,55:147,56:[1,145],57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17,85:90},{12:100,13:148,14:$V2,15:$V3,57:149},{4:150,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,59:$V0,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{4:151,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,56:$V0,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{12:100,13:152,14:$V2,15:$V3,57:153},{4:154,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,59:$V0,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V48,[2,123]),{18:[1,155]},o($V78,[2,16],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V64,$V58),o($V64,$V61,{58:$V63}),{9:$V56,12:77,13:30,14:$V2,15:$V3,16:157,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:156},o($V79,[2,20],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o($V80,[2,21],{31:$V36,32:$V37,33:$V38}),o($V80,[2,22],{31:$V36,32:$V37,33:$V38}),o($V47,[2,8]),{7:158,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V47,[2,10]),{7:159,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:162,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,59:[1,160],60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,65:161,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{56:[1,163]},o($V64,[2,118]),{56:[1,164],66:[1,165]},{11:$V66,56:[2,124],85:166},o($V81,$V82,{85:167,11:$V66,21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V81,[2,113]),o($V83,[2,128],{16:6,20:9,42:15,43:16,83:17,51:26,52:27,53:28,13:30,57:31,67:38,68:39,12:77,7:168,9:$V56,14:$V2,15:$V3,17:$V4,19:$V5,22:$V6,23:$V7,24:$V8,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,54:$V16,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,72:$V23,73:$V24,76:$V25}),o($V81,[2,116],{16:6,20:9,42:15,43:16,83:17,51:26,52:27,53:28,13:30,57:31,67:38,68:39,12:77,7:169,9:$V56,14:$V2,15:$V3,17:$V4,19:$V5,22:$V6,23:$V7,24:$V8,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,54:$V16,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,72:$V23,73:$V24,76:$V25}),{7:162,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,59:[1,170],60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,65:171,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46,59:[1,172]},{7:173,8:46,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V64,[2,61],{58:$V68}),o($V64,[2,62]),{58:$V63},{59:[1,174]},{56:[1,175]},o($V64,[2,65],{58:$V68}),o($V64,[2,66]),{59:[1,176]},o($V64,[2,85]),o($V64,[2,86]),{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46,70:177,71:178,74:$V69,75:$V70},{7:108,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,69:179,70:107,71:109,72:$V23,73:$V24,74:$V69,75:$V70,76:$V25,83:17},o($V64,[2,93]),o($V77,[2,92]),o($V64,[2,94]),{66:[1,181],77:[1,180]},{8:46,9:$V71,12:117,13:118,14:$V2,15:$V3,47:$V72,48:$V73,50:$V74,54:$V75,77:[1,182],78:183,79:115,80:$V76},o($V84,[2,100]),o($V84,$V85,{10:$V59,11:$V60}),o($V84,$V86,{10:$V62,11:[1,184]}),o($V84,[2,104],{11:[1,185]}),{11:[1,186]},{11:[1,187]},{11:[1,188]},{7:189,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V84,[2,111],{42:15,43:16,51:26,52:27,53:28,13:30,57:31,67:38,68:39,12:77,16:190,9:$V56,14:$V2,15:$V3,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,54:$V16,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,72:$V23,73:$V24,76:$V25}),o($V78,[2,18],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),{7:191,8:46,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V87,[2,23],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o($V87,[2,24],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o($V87,[2,25],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o($V87,[2,26],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o($V79,[2,27],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o([5,10,11,18,21,30,41,56,59,66,74,75,77],[2,28],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o($V80,[2,29],{31:$V36,32:$V37,33:$V38}),o($V80,[2,30],{31:$V36,32:$V37,33:$V38}),o($V48,[2,31]),o($V48,[2,32]),o($V48,[2,33]),o($V88,[2,34],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,36:$V41,37:$V42,38:$V43,39:$V44}),o($V88,[2,35],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,36:$V41,37:$V42,38:$V43,39:$V44}),o($V89,[2,36],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38}),o($V89,[2,37],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38}),o($V89,[2,38],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38}),o($V89,[2,39],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38}),o($V88,[2,40],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,36:$V41,37:$V42,38:$V43,39:$V44}),{11:[1,192],21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46},o($V64,[2,68]),{11:$V66,21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46,56:[1,193],85:167},{56:[1,194]},o($V64,[2,71],{58:$V68}),o($V64,[2,72]),{59:[1,195]},{56:[1,196]},o($V64,[2,75],{58:$V68}),o($V64,[2,76]),{59:[1,197]},o($V48,[2,15]),o($V48,[2,122]),{54:$V49,60:$V50,61:$V51,62:$V52,63:$V53,64:$V54,84:$V55},{10:[1,198],21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46},{10:$V90,21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46},o($V64,[2,80]),{59:[1,200],66:$V91},o($V92,[2,82],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V64,[2,56]),o($V64,[2,119]),{7:204,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,56:[1,202],57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,80:$V67,82:203,83:17},{56:[2,125]},{11:$V66,56:[2,126],85:205},o($V83,[2,129],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V81,[2,117],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V64,[2,78]),{59:[1,206],66:$V91},o($V64,[2,59]),{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46,59:[1,207]},o($V64,[2,63]),o($V64,[2,64]),o($V64,[2,67]),o($V64,[2,87]),{7:108,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,69:208,70:107,71:109,72:$V23,73:$V24,74:$V69,75:$V70,76:$V25,83:17},o($V64,[2,88]),o($V64,[2,95]),{9:$V93,12:212,13:118,14:$V2,15:$V3,47:$V72,48:$V73,50:$V74,54:$V75,77:[1,209],79:210,80:$V76},o($V64,[2,97]),{66:[1,214],77:[1,213]},{7:215,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:216,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:217,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:218,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:219,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46,56:[1,220]},o($V84,[2,112],{54:$V49,60:$V50,61:$V51,62:$V52,63:$V53,64:$V54}),o($V78,[2,19],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),{7:221,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V64,[2,69]),o($V64,[2,70]),o($V64,[2,73]),o($V64,[2,74]),o($V64,[2,77]),o($V47,[2,9]),o($V47,[2,11]),o($V64,[2,81]),{7:222,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V64,[2,120]),o($V81,[2,114]),o($V81,$V82,{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),{56:[2,127]},o($V64,[2,79]),o($V64,[2,60]),o($V64,[2,89]),o($V64,[2,96]),o($V84,[2,101]),o($V84,$V85),o($V84,$V86,{11:[1,223]}),o($V64,[2,98]),{9:$V93,12:212,13:118,14:$V2,15:$V3,47:$V72,48:$V73,50:$V74,54:$V75,77:[1,224],79:210,80:$V76},o($V84,$V94,{10:$V90,21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V84,[2,105],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V84,[2,106],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V84,[2,107],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V84,[2,108],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),{11:[1,225]},o($V78,[2,41],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V92,[2,83],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),{7:226,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V64,[2,99]),{7:227,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V84,$V94,{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V84,[2,110],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46})],
defaultActions: {44:[2,1],166:[2,125],205:[2,127]},
performAction(yytext,yyleng,yylineno,yy,yystate /* action[1] */,$$ /* vstack */,_$ /* lstack */) {
/* this == yyval */

const $0 = $$.length - 1;
switch (yystate) {
case 1:
return yy.buildResult($$[$0-1])
break;
case 2:
this.$ = {type:"Block",definitions:$$[$0-1],body:$$[$0],range:this._$.range}
break;
case 3:
this.$ = {type:"Block",definitions:$$[$0],body:{type:"Placeholder",range:[_$[$0].range[1],_$[$0].range[1]]},range:this._$.range}
break;
case 4:
this.$ = {type:"Block",definitions:[],body:$$[$0],range:this._$.range}
break;
case 5:
this.$ = {type:"Block",definitions:[],body:{type:"Placeholder",range:[_$[$0].range[1],_$[$0].range[1]]},range:this._$.range}
break;
case 6: case 82: case 84: case 100: case 113: case 121:
this.$ = [$$[$0]]
break;
case 7:
$$[$0-1].push($$[$0])
break;
case 8:
this.$ = {type:"Definition",declarator:{type:"Declarator",name:null,range:_$[$0-1].range},value:null,range:this._$.range}
break;
case 9:
this.$ = {type:"Definition",declarator:{type:"Declarator",name:null,range:_$[$0-3].range},value:$$[$0-1],range:this._$.range}
break;
case 10:
this.$ = {type:"Definition",declarator:{type:"Declarator",name:$$[$0-1].name,range:_$[$0-1].range},value:null,range:this._$.range}
break;
case 11:
this.$ = {type:"Definition",declarator:{type:"Declarator",name:$$[$0-3].name,range:_$[$0-3].range},value:$$[$0-1],range:this._$.range}
break;
case 12: case 13:
this.$ = {type:"Identifier",name:$$[$0],range:this._$.range}
break;
case 14: case 42: case 43: case 54: case 55: case 115:

break;
case 15:
this.$ = {type:"Function",arguments:[],body:$$[$0-1],legacy:true,range:this._$.range}
break;
case 16:
this.$ = {type:"Function",arguments:[],body:$$[$0],legacy:false,range:this._$.range}
break;
case 17:
this.$ = {type:"SortingFunction",compares:$$[$0],range:this._$.range}
break;
case 18:
this.$ = {type:"Pipeline",left:$$[$0-2],right:$$[$0],range:this._$.range}
break;
case 19:
this.$ = {type:"Pipeline",left:$$[$0-3],right:{type:"Block",definitions:$$[$0-1],body:$$[$0]},range:this._$.range}
break;
case 20: case 21: case 22:
this.$ = {type:"Unary",operator:$$[$0-1],argument:$$[$0],range:this._$.range}
break;
case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40:
this.$ = {type:"Binary",operator:$$[$0-1],left:$$[$0-2],right:$$[$0],range:this._$.range}
break;
case 41:
this.$ = {type:"Conditional",test:$$[$0-4],consequent:$$[$0-2],alternate:$$[$0],range:this._$.range}
break;
case 44:
this.$ = {type:"Data",range:this._$.range}
break;
case 45:
this.$ = {type:"Context",range:this._$.range}
break;
case 46:
this.$ = {type:"Current",range:this._$.range}
break;
case 47:
this.$ = {type:"Arg1",range:this._$.range}
break;
case 48:
this.$ = {type:"Reference",name:$$[$0],range:this._$.range}
break;
case 49: case 50: case 51: case 52: case 90: case 91: case 92: case 93:
this.$ = {type:"Literal",value:$$[$0],range:this._$.range}
break;
case 53:
this.$ = {type:"Template",values:$$[$0],range:this._$.range}
break;
case 56:
this.$ = {type:"SliceNotation",value:null,arguments:$$[$0-1],range:this._$.range}
break;
case 57: case 61:
this.$ = {type:"GetProperty",value:null,property:$$[$0],range:this._$.range}
break;
case 58: case 62:
this.$ = {type:"MethodCall",value:null,method:$$[$0],range:this._$.range}
break;
case 59:
this.$ = {type:"Parentheses",body:$$[$0-1],range:this._$.range}
break;
case 60:
this.$ = {type:"Parentheses",body:{type:"Block",definitions:$$[$0-2],body:$$[$0-1]},range:this._$.range}
break;
case 63:
this.$ = {type:"Map",value:null,query:$$[$0-1],range:this._$.range}
break;
case 64:
this.$ = {type:"Filter",value:null,query:$$[$0-1],range:this._$.range}
break;
case 65:
this.$ = {type:"MapRecursive",value:null,query:{type:"GetProperty",value:null,property:$$[$0]},range:this._$.range}
break;
case 66:
this.$ = {type:"MapRecursive",value:null,query:{type:"MethodCall",value:null,method:$$[$0]},range:this._$.range}
break;
case 67:
this.$ = {type:"MapRecursive",value:null,query:$$[$0-1],range:this._$.range}
break;
case 68:
this.$ = {type:"Pick",value:$$[$0-2],getter:null,range:this._$.range}
break;
case 69:
this.$ = {type:"Pick",value:$$[$0-3],getter:$$[$0-1],range:this._$.range}
break;
case 70:
this.$ = {type:"SliceNotation",value:$$[$0-3],arguments:$$[$0-1],range:this._$.range}
break;
case 71:
this.$ = {type:"GetProperty",value:$$[$0-2],property:$$[$0],range:this._$.range}
break;
case 72:
this.$ = {type:"MethodCall",value:$$[$0-2],method:$$[$0],range:this._$.range}
break;
case 73:
this.$ = {type:"Map",value:$$[$0-3],query:$$[$0-1],range:this._$.range}
break;
case 74:
this.$ = {type:"Filter",value:$$[$0-3],query:$$[$0-1],range:this._$.range}
break;
case 75:
this.$ = {type:"MapRecursive",value:$$[$0-2],query:{type:"GetProperty",value:null,property:$$[$0]},range:this._$.range}
break;
case 76:
this.$ = {type:"MapRecursive",value:$$[$0-2],query:{type:"MethodCall",value:null,method:$$[$0]},range:this._$.range}
break;
case 77:
this.$ = {type:"MapRecursive",value:$$[$0-3],query:$$[$0-1],range:this._$.range}
break;
case 78:
this.$ = {type:"Method",reference:$$[$0-2],arguments:[],range:this._$.range}
break;
case 79:
this.$ = {type:"Method",reference:$$[$0-3],arguments:$$[$0-1],range:this._$.range}
break;
case 80:
this.$ = {type:"Method",reference:{type:"Reference",name:$$[$0-2]},arguments:[],range:this._$.range}
break;
case 81:
this.$ = {type:"Method",reference:{type:"Reference",name:$$[$0-3]},arguments:$$[$0-1],range:this._$.range}
break;
case 83: case 101: case 114: case 122:
$$[$0-2].push($$[$0])
break;
case 85:
this.$=[$$[$0-1], ...$$[$0]]
break;
case 86: case 124:
this.$ = [null,$$[$0]]
break;
case 87: case 126:
this.$ = [$$[$0-1],$$[$0]]
break;
case 88:
this.$=[null, $$[$0-1], ...$$[$0]]
break;
case 89:
this.$=[$$[$0-2], $$[$0-1], ...$$[$0]]
break;
case 94: case 97:
this.$ = {type:"Object",properties:[],range:this._$.range}
break;
case 95:
this.$ = {type:"Object",properties:$$[$0-1],range:this._$.range}
break;
case 96:
this.$ = {type:"Object",properties:$$[$0-2],range:this._$.range}
break;
case 98:
this.$ = {type:"Block",definitions:$$[$0-2],body:{type:"Object",properties:$$[$0-1]},range:this._$.range}
break;
case 99:
this.$ = {type:"Block",definitions:$$[$0-3],body:{type:"Object",properties:$$[$0-2]},range:this._$.range}
break;
case 102:
this.$ = {type:"ObjectEntry",key:{type:"Current"},value:null,range:this._$.range}
break;
case 103:
this.$ = {type:"ObjectEntry",key:{type:"Reference",name:$$[$0]},value:null,range:this._$.range}
break;
case 104:
this.$ = {type:"ObjectEntry",key:$$[$0],value:null,range:this._$.range}
break;
case 105:
this.$ = {type:"ObjectEntry",key:$$[$0-2],value:$$[$0],range:this._$.range}
break;
case 106: case 107: case 108:
this.$ = {type:"ObjectEntry",key:{type:"Literal",value:$$[$0-2]},value:$$[$0],range:this._$.range}
break;
case 109:
this.$ = {type:"ObjectEntry",key:{type:"Identifier",name:"$" + $$[$0-2].name},value:$$[$0],range:this._$.range}
break;
case 110:
this.$ = {type:"ObjectEntry",key:$$[$0-3],value:$$[$0],range:this._$.range}
break;
case 111:
this.$ = {type:"Spread",query:null,array:false,range:this._$.range}
break;
case 112:
this.$ = {type:"Spread",query:$$[$0],array:false,range:this._$.range}
break;
case 116:
this.$ = {type:"Spread",query:null,array:true,range:this._$.range}
break;
case 117:
this.$ = {type:"Spread",query:$$[$0],array:true,range:this._$.range}
break;
case 118:
this.$ = {type:"Array",elements:[],range:this._$.range}
break;
case 119:
this.$ = {type:"Array",elements:$$[$0-1],range:this._$.range}
break;
case 120:
this.$ = {type:"Array",elements:$$[$0-2],range:this._$.range}
break;
case 123:
this.$ = {type:"Compare",query:$$[$0-1],order:$$[$0],range:this._$.range}
break;
case 125:
this.$ = [null,$$[$0-1],$$[$0]]
break;
case 127:
this.$ = [$$[$0-2],$$[$0-1],$$[$0]]
break;
case 128:
this.$ = null
break;
case 129:
this.$ = $$[$0]
break;
}
},
trace(...args) {
        if (this.DEBUG) {
            Jison.print(...args);
        }
    },
parseError(str, hash) {
        if (hash.recoverable) {
            this.trace(str);
        } else {
            const error = new Error(str);
            error.hash = hash;
            throw error;
        }
    },
parse(input, ...parseArgs) {
    // use own constants for source generation reasons
    const SHIFT = 1;
    const REDUCE = 2;
    const ACCEPT = 3;
    const TERROR = 2;
    const EOF = 1;

    const popStack = n => {
        stack.length -= 2 * n;
        vstack.length -= n;
        lstack.length -= n;
    };
    const lex = /** @replace token stack */ () => {
        let token = lexer.lex() || EOF;

        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = this.symbols_[token] || token;
        }

        return token;
    }; /** @replace */

    const lexer = Object.create(this.lexer);
    const ranges = lexer.options && lexer.options.ranges;
    const sharedYY = { // shared state
        ...this.yy,
        parser: this,
        lexer
    };

    lexer.setInput(input, sharedYY);

    if (typeof sharedYY.parseError === 'function') {
        this.parseError = sharedYY.parseError;
    }

    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }

    const table = this.table;
    const yyval = {};
    let yylloc = lexer.yylloc;
    const stack = [0];
    const vstack = [null]; // semantic value stack
    const lstack = [yylloc]; // location stack
    // eslint-disable-next-line no-unused-vars
    let tstack = []; // token stack, used when lex supports token stacks
    let yytext = '';
    let yylineno = 0;
    let yyleng = 0;
    let recovering = 0;
    let symbol;
    let preErrorSymbol;
    while (true) {
        // retreive state number from top of stack
        let state = stack[stack.length - 1];
        let action;

        // use default actions if available
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }

            // read action for current state and first input
            action = table[state] && table[state][symbol];
        }

        // handle parse error
        if (!action || !action[0]) {
            let errorRuleDepth;
            let errStr = '';

            // Return the rule stack depth where the nearest error rule can be found.
            // Return FALSE when no error recovery rule was found.
            function locateNearestErrorRecoveryRule(state) {
                let stackProbe = stack.length - 1;
                let depth = 0;

                // try to recover from error
                while (true) {
                    // check for error recovery rule in this state
                    if (TERROR.toString() in table[state]) {
                        return depth;
                    }

                    if (state === 0 || stackProbe < 2) {
                        return false; // No suitable error recovery rule available.
                    }

                    stackProbe -= 2; // popStack(1): [symbol, action]
                    state = stack[stackProbe];
                    ++depth;
                }
            }

            if (!recovering) {
                // first see if there's any chance at hitting an error recovery rule:
                

                // Report error
                const expected = [];
                for (const p in table[state]) {
                    if (p in this.terminals_ && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }

                errStr = lexer.showPosition
                    ? 'Parse error on line ' + (yylineno + 1) + ':\n' +
                        lexer.showPosition() + '\n' +
                        'Expecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\''
                    : 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' +
                        (symbol === EOF ? 'end of input' : "'" + (this.terminals_[symbol] || symbol) + "'");

                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yylloc,
                    
                    expected
                });
            } else if (preErrorSymbol !== EOF) {
                
            }

            // just recovered from another error
            if (recovering === 3) {
                if (symbol === EOF || preErrorSymbol === EOF) {
                    throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
                }

                // discard current lookahead and grab another
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yylloc = lexer.yylloc;
                symbol = lex();
            }

            // try to recover from error
            if (errorRuleDepth === false) {
                throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
            }

            popStack(errorRuleDepth);
            preErrorSymbol = symbol == TERROR ? null : symbol; // save the lookahead token
            symbol = TERROR; // insert generic error symbol as new lookahead
            state = stack[stack.length - 1];
            action = table[state] && table[state][TERROR];
            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
        }

        // this shouldn't happen, unless resolve defaults are off
        if (Array.isArray(action[0]) && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }

        switch (action[0]) {
            case SHIFT:
                stack.push(symbol);
                vstack.push(lexer.yytext);
                lstack.push(lexer.yylloc);
                stack.push(action[1]); // push state
                symbol = null;

                if (!preErrorSymbol) { // normal execution/no error
                    yyleng = lexer.yyleng;
                    yytext = lexer.yytext;
                    yylineno = lexer.yylineno;
                    yylloc = lexer.yylloc;
                    if (recovering > 0) {
                        recovering--;
                    }
                } else {
                    // error just occurred, resume old lookahead f/ before error
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }

                break;

            case REDUCE: {
                const len = this.productions_[action[1]][1];
                const first = lstack[lstack.length - (len || 1)];
                const last = lstack[lstack.length - 1];

                // perform semantic action
                yyval.$ = vstack[vstack.length - len]; // default to $$ = $1
                // default location, uses first token for firsts, last for lasts
                yyval._$ = {
                    first_line: first.first_line,
                    last_line: last.last_line,
                    first_column: first.first_column,
                    last_column: last.last_column
                };

                if (ranges) {
                    yyval._$.range = [
                        first.range[0],
                        last.range[1]
                    ];
                }

                const actionResult = this.performAction.call(
                    yyval,
                    yytext,
                    yyleng,
                    yylineno,
                    sharedYY,
                    action[1],
                    vstack,
                    lstack,
                    ...parseArgs
                );

                if (typeof actionResult !== 'undefined') {
                    return actionResult;
                }

                // pop off stack
                if (len) {
                    popStack(len);
                }

                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                // goto new state = table[STATE][NONTERMINAL]
                stack.push(table[stack[stack.length - 2]][stack[stack.length - 1]]);
                break;
            }

            case ACCEPT:
                return true;
        }
    }
}};
const parser = (function buildParsers(strictParser) {
    function patch(subject, patches) {
        Object.entries(patches).forEach(([key, patch]) =>
            subject[key] = patch(subject[key])
        );
    }

    // better error details
    const humanTokens = new Map([
        ['EOF', ['<end of input>']],
        ['IDENT', ['ident']],
        ['$IDENT', ['$ident']],
        ['FUNCTION_START', ["'<'"]],
        ['FUNCTION_END', ["'>'"]],
        ['FUNCTION', ["'=>'"]],
        ['NOT', ["'not'"]],
        ['IN', ["'in'"]],
        ['HAS', ["'has'"]],
        ['NOTIN', ["'not in'"]],
        ['HASNO', ["'has no'"]],
        ['AND', ["'and'"]],
        ['OR', ["'or'"]],
        ['STRING', ['string']],
        ['TPL_START', ['template']],
        ['TEMPLATE', ['template']],
        ['NUMBER', ['number']],
        ['REGEXP', ['regexp']],
        ['LITERAL', ["'true'", "'false'", "'null'", "'undefined'"]],
        ['ORDER', ["'asc'", "'desc'", "'ascN'", "'descN'"]]
    ]);
    const tokenForHumans = token => humanTokens.get(token) || `'${token}'`;
    const parseError = function(rawMessage, details = {}, yy) {
        if (details.recoverable) {
            this.trace(rawMessage);
        } else {
            if (Array.isArray(details.inside)) {
                const start = yy.lexer.offset - yy.lexer.match.length;

                yy.lexer.setMatch(
                    start + details.inside[0],
                    start + details.inside[1]
                );
            }

            const yylloc = yy.lexer.yylloc;
            const message = [
                rawMessage.split(/\n/)[0],
                '',
                yy.lexer.showPosition()
            ];
            const expected = !Array.isArray(details.expected) ? null : [...new Set([].concat(
                ...details.expected.map(token => tokenForHumans(token.slice(1, -1)))
            ))];

            if (expected) {
                message.push(
                    '',
                    'Expecting ' + expected.join(', ') + ' got ' + tokenForHumans(details.token)
                );
            }

            const error = new SyntaxError(message.join('\n'));

            error.details = {
                rawMessage: rawMessage,
                text: details.text,
                token: details.token,
                expected,
                loc: {
                    range: yylloc.range,
                    start: {
                        line: yylloc.first_line,
                        column: yylloc.first_column,
                        offset: yylloc.range[0]
                    },
                    end: {
                        line: yylloc.last_line,
                        column: yylloc.last_column,
                        offset: yylloc.range[1]
                    }
                }
            };

            throw error;
        }
    };

    // add new helpers to lexer
    const lineTerminator = new Set(['\n', '\r', '\u2028', '\u2029']);
    const literals = new Map([
        ['null', null],
        ['false', false],
        ['true', true],
        ['Infinity', Infinity],
        ['NaN', NaN]
    ]);
    Object.assign(strictParser.lexer, {
        ident: value => value.replace(/\\u[0-9a-fA-F]{4}/g, m => String.fromCharCode(parseInt(m.slice(2), 16))),

        toLiteral: value => literals.get(value),

        toStringLiteral(value, multiline = false, end = 1) {
            const valueEnd = value.length - end;
            let result = '';

            for (let i = 1; i < valueEnd; i++) {
                if (!multiline && lineTerminator.has(value[i])) {
                    this.parseError('Invalid line terminator', { inside: [i, i + 1] });
                }

                if (value[i] !== '\\') {
                    result += value[i];
                    continue;
                }

                if (i === valueEnd - 1) {
                    this.parseError('Invalid backslash', { inside: [i, i + 1] });
                }

                const next = value[++i];
                switch (next) {
                    case '\r':
                        // ignore line terminator
                        i += value[i + 1] === '\n';  // \r\n
                        break;

                    case '\n':
                    case '\u2028':
                    case '\u2029':
                        // ignore line terminator
                        break;

                    case '0': result += '\0'; break;
                    case 'b': result += '\b'; break;
                    case 'n': result += '\n'; break;
                    case 'r': result += '\r'; break;
                    case 'f': result += '\f'; break;
                    case 't': result += '\t'; break;
                    case 'v': result += '\v'; break;

                    case 'u': {
                        const [hex = ''] = value.slice(i + 1, i + 5).match(/^[0-9a-f]*/i) || [];

                        if (hex.length === 4) {
                            result += String.fromCharCode(parseInt(hex, 16));
                            i += 4;
                            break;
                        }

                        this.parseError('Invalid Unicode escape sequence', {
                            inside: [i - 1, Math.min(i + 1 + hex.length, valueEnd)]
                        });
                        break;
                    }

                    case 'x': {
                        const [hex = ''] = value.slice(i + 1, i + 3).match(/^[0-9a-f]*/i) || [];

                        if (hex.length === 2) {
                            result += String.fromCharCode(parseInt(hex, 16));
                            i += 2;
                            break;
                        }

                        this.parseError('Invalid hexadecimal escape sequence', {
                            inside: [i - 1, Math.min(i + 1 + hex.length, valueEnd)]
                        });
                        break;
                    }

                    default:
                        result += next;
                }
            }

            return result;
        },

        toRegExp(value) {
            const flagsIndex = value.lastIndexOf('/') + 1;
            const flags = value.substr(flagsIndex);

            flags.split('').forEach((flag, idx, array) => {
                const duplicateIndex = array.indexOf(flag, idx + 1);
                if (duplicateIndex !== -1) {
                    this.parseError('Duplicate flag in regexp', {
                        inside: [flagsIndex + duplicateIndex, flagsIndex + duplicateIndex + 1]
                    });
                }
            });

            return new RegExp(
                value.substr(1, value.lastIndexOf('/') - 1),
                flags
            );
        }
    });

    // patch setInput method to add additional lexer fields on init
    patch(strictParser.lexer, {
        setInput: origSetInput => function(input, yy) {
            const commentRanges = [];

            yy.commentRanges = commentRanges;
            yy.buildResult = ast => ({
                ast,
                commentRanges
            });
            yy.parseError = function(...args) {
                // parser doesn't expose sharedState and it's unavailable in parseError
                return parseError.call(this, ...args, yy);
            };
            yy.pps = () => {
                if (!this.eof()) {
                    this.begin('preventPrimitive');
                }
            };

            this.fnOpened = 0;
            this.fnOpenedStack = [];
            this.bracketStack = [];
            this.prevToken = null;
            this.prevYylloc = {
                first_line: 1,
                last_line: 1,
                first_column: 0,
                last_column: 0,
                range: [0, 0]
            };

            return origSetInput.call(this, input, yy);
        }
    });

    //
    // tolerant parser
    //
    const tolerantParser = new strictParser.Parser();
    tolerantParser.lexer = { ...strictParser.lexer };
    tolerantParser.yy = { ...strictParser.yy };

    // patch tolerant parser lexer
    const keywords = [
        'AND', 'OR', 'IN', 'NOTIN', 'HAS', 'HASNO'
    ];
    const words = [...keywords, 'NOT', 'ORDER'];
    const operators = [
        '+', '-', '*', '/', '%', '|',
        '=', '!=', '~=', '>=', '<=', '<', '>'
    ];
    const prev = [
        null, ':', ';',
        ',', '.', '..',
        '(', '[',
        '.(', '..(', '.[',
        'FUNCTION',
        ...operators,
        ...keywords,
        'NOT'
    ];
    const defaultNext = new Set([
        ',', '?', ':', ';', 'EOF',
        ']', ')', '}',
        'TPL_CONTINUE', 'TPL_END',
        ...operators,
        ...keywords,
        'ORDER'
    ]);
    const tokenPair = new Map(prev.map(token => [token, defaultNext]));
    // special cases
    tokenPair.set('{', new Set([',']));
    tokenPair.set('[', new Set([...defaultNext, ',']));
    tokenPair.set('(', new Set([...defaultNext, ',']));

    patch(tolerantParser.lexer, {
        lex: origLex => function patchedLex() {
            const prevOffset = this.offset;
            const nextToken = origLex.call(this);

            if (tokenPair.has(this.prevToken) && tokenPair.get(this.prevToken).has(nextToken)) {
                const yylloc = {
                    first_line: this.prevYylloc.last_line,
                    last_line: this.yylloc.first_line,
                    first_column: this.prevYylloc.last_column,
                    last_column: this.yylloc.first_column,
                    range: [this.prevYylloc.range[1], this.yylloc.range[0]]
                };
                this.unput(this.match);
                this.pushState('preventPrimitive');
                this.done = false;
                this.yytext = '';
                this.yylloc = this.prevYylloc = yylloc;

                // position correction for a white space before a keyword
                if (prevOffset !== this.offset && words.includes(nextToken)) {
                    switch (this._input[prevOffset]) {
                        case ' ':
                        case '\t':
                            yylloc.last_column--;
                            yylloc.range[1]--;
                            break;

                        case '\n': {
                            const lastN = this._input.lastIndexOf('\n', prevOffset - 1);

                            yylloc.last_line--;
                            yylloc.last_column = lastN === -1
                                ? yylloc.last_column - 1
                                : prevOffset - lastN;
                            yylloc.range[1]--;
                            break;
                        }
                    }
                }

                return this.prevToken = 'IDENT';
            }

            this.prevYylloc = this.yylloc;

            // position correction for a white space after a keyword
            if (words.includes(nextToken)) {
                switch (this._input[this.offset]) {
                    case ' ':
                    case '\t':
                        this.prevYylloc = {
                            ...this.prevYylloc,
                            last_column: this.prevYylloc.last_column + 1,
                            range: [this.prevYylloc.range[0], this.prevYylloc.range[1] + 1]
                        };
                        break;

                    case '\n':
                        this.prevYylloc = {
                            ...this.prevYylloc,
                            last_line: this.prevYylloc.last_line + 1,
                            last_column: 0,
                            range: [this.prevYylloc.range[0], this.prevYylloc.range[1] + 1]
                        };
                        break;
                }
            }

            return this.prevToken = nextToken;
        }
    });

    // bracket balance & scope
    const openBalance = new Map([
        ['(', ')'],
        ['.(', ')'],
        ['..(', ')'],
        ['[', ']'],
        ['.[', ']'],
        ['{', '}'],
        ['TPL_START', 'TPL_END']
    ]);
    const closeBalance = new Set([')', ']', '}', 'TPL_END']);
    const balanceScopeLex = origLex => function patchedLex() {
        const token = origLex.call(this);

        if (closeBalance.has(token)) {
            const expected = this.bracketStack.pop();

            if (expected !== token) {
                this.parseError(`Expected "${expected}" got "${token}"`);
            }

            this.fnOpened = this.fnOpenedStack.pop() || 0;
        }

        if (openBalance.has(token)) {
            this.bracketStack.push(openBalance.get(token));
            this.fnOpenedStack.push(this.fnOpened);
            this.fnOpened = 0;
        }

        return token;
    };
    patch(strictParser.lexer, {
        lex: balanceScopeLex
    });
    patch(tolerantParser.lexer, {
        lex: balanceScopeLex
    });

    return {
        parse(source, tolerantMode) {
            return tolerantMode
                ? tolerantParser.parse(source)
                : strictParser.parse(source);
        },
        *tokenize(source, tolerantMode, loc) {
            const parser = tolerantMode ? tolerantParser : strictParser;
            const lexer = Object.create(parser.lexer);

            lexer.setInput(source, { parser });

            while (!lexer.done) {
                const token = {
                    type: lexer.lex(),
                    value: lexer.match,
                    offset: lexer.yylloc.range[0]
                };

                if (loc) {
                    token.loc = {
                        range: lexer.yylloc.range,
                        start: {
                            line: lexer.yylloc.first_line,
                            column: lexer.yylloc.first_column
                        },
                        end: {
                            line: lexer.yylloc.last_line,
                            column: lexer.yylloc.last_column
                        }
                    };
                }

                yield token;
            }
        }
    };
})(new Parser);

export default parser;
